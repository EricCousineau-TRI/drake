#!/usr/bin/env python2

"""
Updates drake to use a specific Python interpreter for both Bazel and the
Python bindings.

This generates (or checks) `./user.bazelrc`.
"""

# Requirements for this script:
# - If configuration file does not exist, generate the file.
# - Otherwise:
#   - If operation is idempotent, perform no operation.
#   - Otherwise, fail, but indicate what options would change.

from __future__ import print_function
import argparse
import os
from os.path import abspath, dirname, join, isabs, isfile, isdir
from subprocess import check_output
import sys


class BazelRc(object):
    # https://docs.bazel.build/versions/master/guide.html#bazelrc-syntax-and-semantics  # noqa
    def __init__(self, options):
        self.options = options

    def is_subset_of(self, other):
        return set(self.options) <= set(other.options)

    def to_text(self):
        lines = [option.to_line() for option in set(self.options)]
        return "\n".join(sorted(lines))

    @classmethod
    def from_file(cls, filename):
        options = []
        with open(filename) as f:
            for line in f.readlines():
                new = cls.Option.list_from_line(line)
                if new:
                    options.extend(new)
        return cls(options)

    class Option(object):
        def __init__(self, command, flag):
            self.command = command
            self.flag = flag

        def __hash__(self):
            return hash(self._to_tuple())

        def __eq__(self, other):
            return self._to_tuple() == other._to_tuple()

        def _to_tuple(self):
            return (self.command, self.flag)

        def to_line(self):
            return "{} {}".format(self.command, self.flag)

        @classmethod
        def list_from_line(cls, text):
            # Assumes that no strings contain '#'.
            # Split bazelrc into tokens, strip any and all comments.
            # Does not do shell lexing.
            text = text.split("#")[0].strip()
            if len(text) == 0:
                return None
            words = text.split()
            assert len(words) > 1, "Invalid syntax"
            command = words[0]
            options = []
            for flag in words[1:]:
                options.append(cls(command, flag))
            return options


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--python_bin", type=str, required=True,
        help="Python binary. Must be an absolut path.")
    args = parser.parse_args()

    workspace_dir = dirname(dirname(abspath(__file__)))
    target_relpath = "user.bazelrc"

    # Python.
    # N.B. Configuration checks are performed by `tools/python/repository.bzl`.
    python_bin = args.python_bin
    if not isabs(python_bin):
        parser.error("Please specify an absolute path to the binary.")
    if not isfile(python_bin):
        parser.error("File does not exist: {}".format(python_bin))

    # Write target configuration file.
    target_abspath = join(workspace_dir, target_relpath)
    new_bazelrc = BazelRc([
        BazelRc.Option(
            "build", "--action_env=PYTHON_BIN_PATH=" + python_bin),
        BazelRc.Option("build", "--python_path=" + python_bin),
    ])
    new_bazelrc_text = new_bazelrc.to_text()
    if isfile(target_abspath):
        existing_bazelrc = BazelRc.from_file(target_abspath)
        if new_bazelrc.is_subset_of(existing_bazelrc):
            print("Unchanged: {}".format(target_abspath))
        else:
            # Do not append, just inform as an error.
            parser.error((
                "Changes are required to './user.bazelrc'.\n"
                "Please manually add the following lines:\n\n{}\n"
                ).format(new_bazelrc_text))
    else:
        with open(target_abspath, 'w') as f:
            f.write("# Generated by `./setup/user_configure`.\n")
            f.write(new_bazelrc_text + "\n")
        print("Wrote: {}".format(target_abspath))
    print("  Python: {}".format(python_bin))


if __name__ == "__main__":
    main()

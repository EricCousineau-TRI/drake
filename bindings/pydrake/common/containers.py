"""Provides extensions for containers of Drake-related objects."""

from collections import Counter
from enum import Enum

import numpy as np


class _classproperty:
    # See: https://stackoverflow.com/a/5192374/7829525
    def __init__(self, fget):
        self._fget = fget

    def __get__(self, obj, cls):
        return self._fget(cls)


class _EqualityProxyBase:
    # Wraps an object with a non-compliant `__eq__` operator (returns a
    # non-bool convertible expression) with a custom compliant `__eq__`
    # operator.
    def __init__(self, value):
        self._value = value

    def _get_value(self):
        return self._value

    def __hash__(self):
        return hash(self._value)

    def __eq__(self, other):
        raise NotImplemented("Abstract method")

    value = property(_get_value)


class _DictKeyWrap(dict):
    # Wraps a dictionary's key access. For a key of a type `TOrig`, this
    # dictionary will provide a key of type `TProxy`, that should proxy the
    # original key.
    def __init__(self, dict_in, key_wrap, key_unwrap):
        # @param dict_in Dictionary with keys of types TOrig (not necessarily
        # homogeneous).
        # @param key_wrap Functor that maps from TOrig -> TProxy.
        # @param key_unwrap Functor that maps from TProxy -> TOrig.
        dict.__init__(self)
        # N.B. Passing properties to these will cause an issue. This can be
        # sidestepped by storing the properties in a `dict`.
        self._key_wrap = key_wrap
        self._key_unwrap = key_unwrap
        for key, value in dict_in.items():
            self[key] = value

    def __setitem__(self, key, value):
        return dict.__setitem__(self, self._key_wrap(key), value)

    def __getitem__(self, key):
        return dict.__getitem__(self, self._key_wrap(key))

    def __delitem__(self, key):
        return dict.__delitem__(self, self._key_wrap(key))

    def __contains__(self, key):
        return dict.__contains__(self, self._key_wrap(key))

    def items(self):
        return zip(self.keys(), self.values())

    def keys(self):
        return (self._key_unwrap(key) for key in dict.keys(self))

    def raw(self):
        """Returns a dict with the original keys.

        Note:
            Copying to a `dict` will maintain the proxy keys.
        """
        return dict(self.items())


class EqualToDict(_DictKeyWrap):
    """Implements a dictionary where keys are compared using type and
    `lhs.EqualTo(rhs)`.
    """
    def __init__(self, *args, **kwargs):

        class Proxy(_EqualityProxyBase):
            def __eq__(self, other):
                T = type(self.value)
                return (isinstance(other.value, T)
                        and self.value.EqualTo(other.value))

            # https://stackoverflow.com/a/1608907/7829525
            __hash__ = _EqualityProxyBase.__hash__

        dict_in = dict(*args, **kwargs)
        _DictKeyWrap.__init__(self, dict_in, Proxy, Proxy._get_value)


class NamedViewBase:
    """Base for classes generated by ``namedview``.

    Inspired by: https://bitbucket.org/ericvsmith/namedlist
    """

    # N.B. `i` corresponds to the *flattened* index.

    # To be specified by `namedview()`.
    _field_names = None
    _field_names_flat = None
    _size = None

    def __init__(self, value):
        """Creates a view on ``value``. Any mutations on this instance will be
        reflected in ``value``, and any mutations on ``value`` will be
        reflected in this instance."""
        if None in (self._field_names, self._field_names_flat, self._size):
            raise RuntimeError("Class must be generated by ``namedview``")
        assert self._size == len(value)
        object.__setattr__(self, '_value', value)

    @classmethod
    def get_fields(cls, *, flat=True):
        """Returns all fields for this class or object."""
        if flat:
            return cls._field_names_flat
        else:
            return cls._field_names

    def __getitem__(self, i):
        return self._value[i]

    def __setitem__(self, i, value_i):
        self._value[i] = value_i

    def __setattr__(self, name, value):
        """Prevent setting additional attributes."""
        if not hasattr(self, name):
            raise AttributeError("Cannot add attributes!")
        object.__setattr__(self, name, value)

    @_classproperty
    def size(cls):
        return cls._size

    def __len__(self):
        return self._size

    def __iter__(self):
        return iter(self._value)

    def __array__(self):
        """Proxy for use with NumPy."""
        return np.asarray(self._value)

    def __repr__(self):
        """Provides human-readable breakout of each field and value, using
        flattend representation."""
        value_strs = []
        for i, field in enumerate(self._field_names_flat):
            value_strs.append("{}={}".format(field, repr(self[i])))
        return "{}({})".format(
            self.__class__.__qualname__, ", ".join(value_strs)
        )

    @staticmethod
    def _property_to_access_scalar(i):
        # Maps an item (at a given index) to a property.
        return property(
            fget=lambda self: self[i],
            fset=lambda self, value: self.__setitem__(i, value),
        )

    @staticmethod
    def _property_to_access_subview(subview_cls, slice_):
        return property(
            # Return view of slice.
            fget=lambda self: subview_cls(self[slice_]),
            # Just set value.
            fset=lambda self, value: (
                self.__setitem__(slice_, np.asarray(value))
            ),
        )


class _NestMode(Enum):
    NoNesting = 1
    ViaStrWithPeriod = 2
    ViaSubview = 3


def _check_fields_and_nest_mode(fields):
    nest_mode = _NestMode.NoNesting
    # Ensure we're all unique.
    duplicates = {}
    counter = Counter(fields)
    for key, count in counter.items():
        if count > 1:
            duplicates[key] = count
    if len(duplicates) > 0:
        raise RuntimeError(
            f"Duplicate (non-unique) fields:\n"
            f"  {repr(duplicates)}"
        )
    # First, check nesting mode.
    for field in fields:
        # Consistency.
        is_mixed = False
        if isinstance(field, type) and issubclass(field, NamedViewBase):
            is_mixed = (nest_mode == _NestMode.ViaStrWithPeriod)
            nest_mode = _NestMode.ViaSubview
        elif isinstance(field, str):
            if len(field) == 0:
                raise RuntimeError("Field names cannot be empty")
            # TODO(eric.cousineau): Validate via regex.
            if "." in field:
                is_mixed = (nest_mode == _NestMode.ViaSubview)
                nest_mode = _NestMode.ViaStrWithPeriod
        else:
            raise RuntimeError(
                f"Fields must either be a `str` or a `namedview`: "
                f"{repr(field)}"
            )
        if is_mixed:
            raise RuntimeError(
                f"Nested fields must be specified consistently. Either "
                f"use `str` with '.', or nested `namedview`: "
                f"{repr(fields)}"
            )
    return nest_mode


def _unflatten_fields(fields):
    """
    Nodes are either non-leaf or leaf; cannot intermix.
    """
    i = 0
    parsed_fields = []
    # Record root-level fields parsed; if we re-encounter the same field, then
    # there was a non-contiguous nesting.
    # We know this because our check above checks against naive duplicates.
    root_names = set()
    while i < len(fields):
        field = fields[i]
        pieces = field.split(".")
        name = pieces[0]
        if name in root_names:
            raise RuntimeError(
                f"A nested field was specified non-contiguously, which "
                f"is invalid: {name}"
            )
        root_names.add(name)
        if len(pieces) > 1:
            # Consume all tokens that begin with this one (including current
            # token), but strip off prefix. Do naive recursion (inefficient,
            # but meh).
            subfields = []
            while i < len(fields):
                next_field = fields[i]
                next_pieces = next_field.split(".")
                if next_pieces[0] == name:
                    subfield = ".".join(next_pieces[1:])
                    subfields.append(subfield)
                    i += 1
                else:
                    break
            assert len(subfields) >= 1  # Since we include current token.
            subfields = _unflatten_fields(subfields)
            subview = namedview(f"{name}_", subfields)
            parsed_fields.append(subview)
        else:
            i += 1
            parsed_fields.append(field)
    return parsed_fields


def namedview(name, fields):
    """
    Creates a class that is a named view with given ``fields``. When the class
    is instantiated, it must be given the object that it will be a proxy for.
    Similar to ``namedtuple``.

    The following aspects apply:

    - This only constrains the *leading* dimension of the array (thus you could
      have a shape of ``(N, ...)``).
    - This does *not* constrain the dtype. This wrapped array can an np.ndarray
      of any dtype (e.g. ``dtype=float``, ``dtype=object``).
    - Field names cannot end with ``_``.
    - Nested subviews must end with ``_`` (so that we can add the class without
      colliding with the property).

    Example::
        MyView = namedview("MyView", ('a', 'b'))

        value = np.array([1, 2])
        view = MyView(value)
        view.a = 10  # `value` is now [10, 2]
        value[1] = 100  # `view` is now [10, 100]
        view[:] = 3  # `value` is now [3, 3]

    For additional API and implementation details, see ``NamedViewBase``.
    """
    # TODO(eric.cousineau): The requirement that subviews must end with `_`
    # precludes composition of predefined views. Should relax this in the
    # future for simplicity.
    if len(fields) == 0:
        raise RuntimeError("Cannot create empty namedview.")
    base_cls = NamedViewBase
    view_cls_dict = dict()
    size = 0
    field_names = []
    field_names_flat = []
    nest_mode = _check_fields_and_nest_mode(fields)
    if nest_mode == _NestMode.ViaStrWithPeriod:
        fields = _unflatten_fields(fields)
    for field in fields:
        i = size
        if isinstance(field, str):
            field_name = field
            if field_name.endswith("_"):
                raise RuntimeError(
                    f"str fields cannot end with `_`: {field_name}"
                )
            assert "." not in field_name, repr(field)
            field_names.append(field_name)
            field_names_flat.append(field_name)
            field_size = 1
            prop = NamedViewBase._property_to_access_scalar(i)
        elif isinstance(field, type) and issubclass(field, NamedViewBase):
            subview_cls = field
            subview_name = subview_cls.__name__
            if not subview_name.endswith("_"):
                raise RuntimeError(
                    f"Nested subview class name must end with `_`: "
                    f"{subview_cls}"
                )
            field_name = subview_name[:-1]
            field_names.append(field_name)
            field_names_flat += [
                f"{field_name}.{x}"
                for x in subview_cls.get_fields()
            ]
            field_size = subview_cls.size
            slice_ = slice(size, size + field_size)
            prop = NamedViewBase._property_to_access_subview(
                subview_cls, slice_
            )
            # Ensure that we can now access the subview cls via the main view
            # cls.
            subview_cls.__qualname__ = f"{name}.{subview_name}"
            view_cls_dict[subview_name] = subview_cls
        else:
            assert False, repr((field, fields))
        size += field_size
        view_cls_dict[field_name] = prop
    view_cls_dict["_size"] = size
    view_cls_dict["_field_names"] = tuple(field_names)
    view_cls_dict["_field_names_flat"] = tuple(field_names_flat)
    view_cls = type(name, (base_cls,), view_cls_dict)
    return view_cls

"""Provides extensions for containers of Drake-related objects."""

import numpy as np


class _classproperty:
    # See: https://stackoverflow.com/a/5192374/7829525
    def __init__(self, fget):
        self._fget = fget

    def __get__(self, obj, cls):
        return self._fget(cls)


class _EqualityProxyBase:
    # Wraps an object with a non-compliant `__eq__` operator (returns a
    # non-bool convertible expression) with a custom compliant `__eq__`
    # operator.
    def __init__(self, value):
        self._value = value

    def _get_value(self):
        return self._value

    def __hash__(self):
        return hash(self._value)

    def __eq__(self, other):
        raise NotImplemented("Abstract method")

    value = property(_get_value)


class _DictKeyWrap(dict):
    # Wraps a dictionary's key access. For a key of a type `TOrig`, this
    # dictionary will provide a key of type `TProxy`, that should proxy the
    # original key.
    def __init__(self, dict_in, key_wrap, key_unwrap):
        # @param dict_in Dictionary with keys of types TOrig (not necessarily
        # homogeneous).
        # @param key_wrap Functor that maps from TOrig -> TProxy.
        # @param key_unwrap Functor that maps from TProxy -> TOrig.
        dict.__init__(self)
        # N.B. Passing properties to these will cause an issue. This can be
        # sidestepped by storing the properties in a `dict`.
        self._key_wrap = key_wrap
        self._key_unwrap = key_unwrap
        for key, value in dict_in.items():
            self[key] = value

    def __setitem__(self, key, value):
        return dict.__setitem__(self, self._key_wrap(key), value)

    def __getitem__(self, key):
        return dict.__getitem__(self, self._key_wrap(key))

    def __delitem__(self, key):
        return dict.__delitem__(self, self._key_wrap(key))

    def __contains__(self, key):
        return dict.__contains__(self, self._key_wrap(key))

    def items(self):
        return zip(self.keys(), self.values())

    def keys(self):
        return (self._key_unwrap(key) for key in dict.keys(self))

    def raw(self):
        """Returns a dict with the original keys.

        Note:
            Copying to a `dict` will maintain the proxy keys.
        """
        return dict(self.items())


class EqualToDict(_DictKeyWrap):
    """Implements a dictionary where keys are compared using type and
    `lhs.EqualTo(rhs)`.
    """
    def __init__(self, *args, **kwargs):

        class Proxy(_EqualityProxyBase):
            def __eq__(self, other):
                T = type(self.value)
                return (isinstance(other.value, T)
                        and self.value.EqualTo(other.value))

            # https://stackoverflow.com/a/1608907/7829525
            __hash__ = _EqualityProxyBase.__hash__

        dict_in = dict(*args, **kwargs)
        _DictKeyWrap.__init__(self, dict_in, Proxy, Proxy._get_value)


class NamedViewBase:
    """Base for classes generated by ``namedview``.

    Inspired by: https://bitbucket.org/ericvsmith/namedlist
    """

    # N.B. `i` corresponds to the *flattened* index.

    # To be specified by `namedview()`.
    _field_names = None
    _field_names_flat = None
    _size = None

    def __init__(self, value):
        """Creates a view on ``value``. Any mutations on this instance will be
        reflected in ``value``, and any mutations on ``value`` will be
        reflected in this instance."""
        if None in (self._field_names, self._field_names_flat, self._size):
            raise RuntimeError("Class must be generated by ``namedview``")
        assert self._size == len(value)
        object.__setattr__(self, '_value', value)

    @classmethod
    def get_fields(cls, *, flat=True):
        """Returns all fields for this class or object."""
        if flat:
            return cls._field_names_flat
        else:
            return cls._field_names

    @_classproperty
    def size(cls):
        return cls._size

    def __getitem__(self, i):
        return self._value[i]

    def __setitem__(self, i, value_i):
        self._value[i] = value_i

    def __setattr__(self, name, value):
        """Prevent setting additional attributes."""
        if not hasattr(self, name):
            raise AttributeError("Cannot add attributes!")
        object.__setattr__(self, name, value)

    def __len__(self):
        return len(self._value)

    def __iter__(self):
        return iter(self._value)

    def __array__(self):
        """Proxy for use with NumPy."""
        return np.asarray(self._value)

    def __repr__(self):
        """Provides human-readable breakout of each field and value, using
        flattend representation."""
        value_strs = []
        for i, field in enumerate(self._field_names_flat):
            value_strs.append("{}={}".format(field, repr(self[i])))
        return "{}({})".format(self.__class__.__name__, ", ".join(value_strs))

    @staticmethod
    def _item_property(i):
        # Maps an item (at a given index) to a property.
        return property(
            fget=lambda self: self[i],
            fset=lambda self, value: self.__setitem__(i, value))

    @staticmethod
    def _subview_property(view_cls, slice_):
        return property(
            # Return view of slice.
            fget=lambda self: view_cls(self[slice_]),
            # Just set value.
            fset=lambda self, value: self.__setitem__(slice_, value))


def _maybe_unflatten(fields):
    # TODO(eric.cousineau): Finish this.
    assert False
    is_nested_via_str = None
    for field in fields:
        # Consistency.
        is_nested_via_str_i = False
        bad_mixed = False
        if isinstance(field, NamedViewBase):
            bad_mixed = (is_nested_via_str in (None, False))
            is_nested_via_str = False
        elif "." in field:
            bad_mixed = (is_nested_via_str in (None, True))
            is_nested_via_str_i = True
            is_nested_via_str = True
        if bad_mixed:
            raise RuntimeError(
                "Nested fields must be specified in a consistent fashion: "
                "either use strings with '.', or nested namedview()")

        if is_nested_via_str_i:
            # Consume all tokens
            ...


def namedview(name, fields):
    """
    Creates a class that is a named view with given ``fields``. When the class
    is instantiated, it must be given the object that it will be a proxy for.
    Similar to ``namedtuple``.

    Example::
        MyView = namedview("MyView", ('a', 'b'))

        value = np.array([1, 2])
        view = MyView(value)
        view.a = 10  # `value` is now [10, 2]
        value[1] = 100  # `view` is now [10, 100]
        view[:] = 3  # `value` is now [3, 3]

    For more details, see ``NamedViewBase``.
    """
    base_cls = (NamedViewBase,)
    type_dict = dict()
    size = 0
    field_names = []
    field_names_flat = []
    # fields = _maybe_unflatten(fields)
    for field in fields:
        i = size
        if isinstance(field, str):
            name_f = field
            size_f = 1
            prop = NamedViewBase._item_property(i)
            field_names.append(name_f)
            field_names_flat.append(name_f)
        elif issubclass(field, NamedViewBase):
            view_cls = field
            size_f = view_cls.size
            slice_ = slice(size, size + size_f)
            prop = NamedViewBase._subview_property(view_cls, slice_)
            assert view_cls.__name__.endswith("_"), view_cls
            name_f = view_cls.__name__[:-1]
            field_names.append(name_f)
            field_names_flat += [
                f"{name_f}.{x}"
                for x in view_cls.get_fields()
            ]
        else:
            assert False, repr(field)
        size += size_f
        type_dict[name_f] = prop
    type_dict["_size"] = size
    type_dict["_field_names"] = tuple(field_names)
    type_dict["_field_names_flat"] = tuple(field_names_flat)
    cls = type(name, base_cls, type_dict)
    return cls
